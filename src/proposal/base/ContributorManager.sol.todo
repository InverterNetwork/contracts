// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity ^0.8.0;

// Internal Dependencies
import {Types} from "src/common/Types.sol";
import {Module} from "src/modules/base/Module.sol";

// Internal Libraries
import {LibString} from "src/common/LibString.sol";

// Interfaces
import {IProposal} from "src/interfaces/IProposal.sol";

/**
 * @title Contributor manager module
 *
 * @dev
 * This Module handles the list of active contributors in the inverter.
 *
 * It saves the assigned role and salary of each contributor in a registry,
 * and keeps a list of active contributors in the style of the Gnosis Safe
 * OwnerManager (https://github.com/safe-global/safe-contracts/blob/main/contracts/base/OwnerManager.sol)
 *
 * Along each contributor address, the contract stores a salary and a role. This
 * role is NOT intended for access control, but for offchain retrieval of team
 * assignement or similar information.
 *
 * Each active contributor is only represented once.
 *
 */

contract ContributorManager {
    using LibString for string;

    // @todo mp: Is in interface.
    struct Contributor {
        string name;
        bytes32 role;
        uint salary; // @todo mp, nuggan: What exactly is contributor's salary?
    }
    //--------------------------------------------------------------------------
    // Modifiers

    modifier validName(string memory name) {
        if (name.isEmpty()) {
            revert Module__ContributorManager__InvalidContributorName();
        }
        _;
    }

    modifier validRole(string memory role) {
        if (role.isEmpty()) {
            revert Module__ContributorManager__InvalidContributorRole();
        }
        _;
    }

    modifier validSalary(uint salary) {
        if (salary == 0) {
            revert Module__ContributorManager__InvalidContributorSalary();
        }
        _;
    }

    modifier validAddress(address who) {
        // @todo mp: Make gas optimized.
        bool isZero = who == address(0);
        bool isSentinel = who == _SENTINEL;
        bool isThis = who == address(this);

        if (isZero || isSentinel || isThis) {
            revert Module__ContributorManager__InvalidContributorAddress();
        }
        _;
    }

    modifier isNotActiveContributor(address who) {
        if (isActiveContributor(who)) {
            revert Module__ContributorManager__ActiveContributor();
        }
        _;
    }

    modifier _isActiveContributor(address who) {
        if (!isActiveContributor(who)) {
            revert Module__ContributorManager_NotActiveContributor();
        }
        _;
    }

    modifier onlyConsecutiveContributors(address _current, address _prev) {
        //require that the contributors are indeed consecutive
        if (activeContributors[_prev] != _current) {
            revert Module__ContributorManager__ContributorsNotConsecutive();
        }
        _;
    }

    modifier contributorNotActive(address _who) {
        if (isActiveContributor(_who)) {
            revert Module__ContributorManager__contributorAlreadyActive();
        }
        _;
    }

    modifier contributorIsActive(address _who) {
        if (!isActiveContributor(_who)) {
            revert Module__ContributorManager__contributorNotActive();
        }
        _;
    }

    //--------------------------------------------------------------------------
    // Constants

    address private constant _SENTINEL = address(0x1);

    //--------------------------------------------------------------------------
    // Storage

    mapping(address => Contributor) private _contributorRegistry;

    /// @notice Mapping of active contributors. Every address points to the
    ///         last one added before them.
    ///         activeContributors[SENTINEL_CONTRIBUTORS] points to the last
    ///         added address, to aid retrieval.
    ///         The first added address points to SENTINEL_CONTRIBUTORS to
    //          signal end of list
    mapping(address => address) private _contributors;

    uint private _contributorCounter;

    //--------------------------------------------------------------------------
    // Internal Functions

    function __ContributorManager_init() internal onlyInitializing {
        // Set up the sentinel to signal an empty list of active contributors.
        _activeContributors[_SENTINEL] = _SENTINEL;
    }

    function __ContributorManager_addContributor(
        address who,
        string memory name,
        bytes32 role,
        uint salary
    )
        internal
        validAddress(who)
        validName(name)
        validRole(role)
        validSalary(salary)
        isNotActiveContributor(who)
    {
        // Create new Contributor instance.
        Contributor memory c = Contributor(name, role, salary);

        // Add address to _contributors mapping.
        _contributors[_who] = _contributors[_SENTINEL];
        _contributors[_SENTINEL] = who;
        _contributorCounter++;

        // Add Contributor instance to registry.
        _contributorRegistry[_who] = c;

        emit ContributorAdded(who);
    }

    function __ContributorManager_removeContributor(
        address who,
        address prevContrib
    )
        internal
        validAddress(who)
        onlyConsecutiveContributors(who, prevContrib)
    {
        // Remove Contributor instance from registry.
        delete _contributorRegistry[who];

        // Remove address from active contributors list.
        _contributors[prevContrib] = _contributors[who];
        _contributors[who] = address(0);
        _contributorCounter--;

        emit ContributorRemoved(who);
    }

    function __ContributorManager_updateContributorsRole(
        address who,
        bytes32 role
    ) internal validAddress(_who) validRole(role) isActiveContributor(who) {
        emit ContributorsRoleUpdated(who, role, _contributorRegistry[who].role);
        _contributorRegistry[who].role = _role;
    }

    function __ContributorManager_updateContributorsSalary(
        address who,
        uint salary
    )
        internal
        validAddress(_who)
        validSalary(salary)
        _isActiveContributor(who)
    {
        emit ContributorsSalaryUpdated(
            who, salary, _contributorRegistry[who].salary
            );
        _contributorRegistry[who].salary = salary;
    }

    //--------------------------------------------------------------------------
    // Public View Functions

    /// @inheritdoc IContributorManager
    function getContributorInformation(address who)
        external
        view
        _isActiveContributor(who)
        returns (bytes32, uint)
    {
        return _contributors[who];
    }

    /// @inheritdoc IContributorManager
    function isActiveContributor(address who) public view returns (bool) {
        return who != _SENTINEL && _contributors[who] != address(0);
    }

    /// @inheritdoc IContributorManager
    function listActiveContributors()
        external
        view
        returns (address[] memory)
    {
        address[] memory result = new address[](_contributorCounter);

        // Populate result array.
        uint index = 0;
        address elem = _contributors[_SENTINEL];
        while (elem != _SENTINEL) {
            result[index] = elem;
            elem = _contributors[elem];
            index++;
        }

        return result;
    }
}
